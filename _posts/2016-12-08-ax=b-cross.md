---
title:      "Solving Linear System for busy students"
---

Here is the problem : you have to solve Ax=b in E where dim(E)=3.
Let's say you have :
{% highlight matlab linenos %}
    A = [2 3 4;
        4 3 2;
        6 5 1];

    x = [x1;
        x2;
        x3];

    b = [1;
        2;
        3];
{% endhighlight %}

As you're a busy student, you don't have enough time to do a lot of products and additions or worse : a pivot rotation !!

## Here is the tip...
Use good ol' geometry !

1. By doing a cross product between 2 vectors you got a different direction.
2. Use normal plan equations by taking the coefficients from columns. You got a vector of "magic coefficients".
3. If you multiply the rows by these coefficients and then add them, your third vector would be alone !
4. Then you normalize this vector according to b. Do it 3 times. That's it.

Let's say you have A matrix defined as below :
{% highlight matlab linenos %}
    A = [a11 a12 a13;
        a21 a22 a23;
        a31 a32 a33];
{% endhighlight %}

You got the "magic coefficients" that make 2 vectors vanish by doing cross product :
For instance if you want to separate the third vector you do :
{% highlight matlab linenos %}
    [a11; a21; a31] ^ [a12; a22; a32] = [c1; c2; c3]
{% endhighlight %}

Now if you multiply these coeffs and add the rows you got your separated vector.

## Simple code
{% highlight matlab linenos %}
    function [result] = Axb (A,b)

    length_A = length(A);

    coeff_x = cross(A(:,2),A(:,3));
    coeff_y = cross(A(:,1),A(:,3));
    coeff_z = cross(A(:,1),A(:,2));

    coeff_x_sum = A(1,1)*coeff_x(1) + A(2,1)*coeff_x(2) + A(3,1)*coeff_x(3);
    coeff_y_sum = A(1,2)*coeff_y(1) + A(2,2)*coeff_y(2) + A(3,2)*coeff_y(3);
    coeff_z_sum = A(1,3)*coeff_z(1) + A(2,3)*coeff_z(2) + A(3,3)*coeff_z(3);

    x = (b(1)*coeff_x(1) + b(2)*coeff_x(2) + b(3)*coeff_x(3))/coeff_x_sum;
    y = (b(1)*coeff_y(1) + b(2)*coeff_y(2) + b(3)*coeff_y(3))/coeff_y_sum;
    z = (b(1)*coeff_z(1) + b(2)*coeff_z(2) + b(3)*coeff_z(3))/coeff_z_sum;

    result = [x;y;z];

    endfunction
{% endhighlight %}

And the test program here :

{% highlight matlab linenos %}
    A = [2 3 4;
        4 3 2;
        6 5 1];
        
    b = [1;
        2;
        3];

    eps = 10^(-6);
        
    x = Axb(A,b);

    test1 = (norm(A*x - b)) < eps
{% endhighlight %}

# Parallelizable
Note that this approach is highly parallelizable since you do not have to make a pivot and so rely on last
operations. You can just works separately on the 3 vectors.

## Important
Ok this saves a lot of time if you are in exam but remember that it works very well because of cross product formula is
very easy in 3rd dimension. Unfortunately cross-product formula only exists for space of dimension 3 or 7.
Sorry.



I know...